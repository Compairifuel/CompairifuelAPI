package org.compairifuel.compairifuelapi.authorization.presentation;

import jakarta.inject.Inject;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.HttpHeaders;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import lombok.extern.java.Log;
import org.compairifuel.compairifuelapi.authorization.service.IAuthorizationService;
import org.compairifuel.compairifuelapi.authorization.service.domain.AccessTokenDomain;
import org.compairifuel.compairifuelapi.utils.presentation.CacheControlDirectives;
import org.compairifuel.compairifuelapi.utils.presentation.validation.RedirectURI;

import java.net.URI;

@Log(topic = "AuthorizationController")
@Path("/oauth")
public class AuthorizationController {
    private IAuthorizationService authorizationService;

    @Inject
    public void setAuthorizationService(IAuthorizationService authorizationService) {
        this.authorizationService = authorizationService;
    }

    /**
     * @param responseType  The response_type parameter must be set to “code”.
     * @param redirectUri   A Redirect URI.
     * @param clientId      The client identifier as described in Section 2.2 of OAuth 2.0 [RFC6749].
     * @param codeChallenge A Base64 encoded SHA256 hash required for PKCE support.
     * @param state          A random string generated by the client.
     * @return
     */
    @GET
    @Path("")
    @Produces(MediaType.APPLICATION_JSON)
    public Response getAuthorizationCode(@QueryParam("response_type") @Pattern(regexp = "(code)", message = "response_type must be set to “code”.") String responseType, @QueryParam("client_id") String clientId, @QueryParam("redirect_uri") @NotBlank(message = "redirect_uri cannot be blank!") @RedirectURI(message = "redirect_uri must be a valid uri.") String redirectUri, @QueryParam("code_challenge") @NotBlank(message = "code_challenge cannot be blank!") String codeChallenge, @QueryParam("state") @NotBlank(message = "state cannot be blank!") String state) {
        URI redirectToURI = authorizationService.getAuthorizationCode(responseType, clientId, redirectUri, codeChallenge, state);
        return Response.seeOther(redirectToURI).header(HttpHeaders.CACHE_CONTROL, CacheControlDirectives.NO_STORE).build();
    }

    /**
     * @param grantType    The grant_type parameter must be set to “authorization_code”.
     * @param code          This parameter is the authorization code that the client previously received from the authorization request.
     * @param redirectUri  If the redirect URI was included in the initial authorization request, the service must require it in the token request as well.
     *                      The redirect URI in the token request must be an exact match of the redirect URI that was used when generating the authorization code.
     *                      The service must reject the request otherwise.
     * @param clientId     The client identifier as described in Section 2.2 of OAuth 2.0 [RFC6749].
     * @param codeVerifier A plaintext string to prove it has the secret used to generate hash of the code_challenge parameter used in the authorization request.
     * @return
     */
    @POST
    @Path("/token")
    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
    @Produces(MediaType.APPLICATION_JSON)
    public Response getAccessToken(@FormParam("grant_type") @Pattern(regexp = "authorization_code", message = "grant_type must be set to “authorization_code”.") String grantType, @FormParam("code") @NotBlank(message = "code cannot be blank!") String code, @FormParam("redirect_uri") @NotBlank(message = "redirect_uri cannot be blank!") @RedirectURI(message = "redirect_uri must be a valid uri.") String redirectUri, @FormParam("client_id") String clientId, @FormParam("code_verifier") @NotBlank(message = "code_verifier cannot be blank!") String codeVerifier) {
        AccessTokenDomain accessTokenDomain = authorizationService.getAccessToken(grantType, code, redirectUri, clientId, codeVerifier);

        AccessTokenResponseDTO response = buildAccessTokenResponseDTO(accessTokenDomain);

        return Response.ok().entity(response).header(HttpHeaders.CACHE_CONTROL, CacheControlDirectives.NO_STORE).build();
    }

    /**
     * @param grantType    The grant_type parameter must be set to “refresh_token”.
     * @param refreshToken The refresh token received from the previous access token.
     * @param clientId     The client identifier as described in Section 2.2 of OAuth 2.0 [RFC6749].
     * @param codeVerifier A plaintext string to prove it has the secret used to generate hash of the code_challenge parameter used in the authorization request.
     * @return
     */
    @GET
    @Path("/refresh")
    @Produces(MediaType.APPLICATION_JSON)
    public Response getAccessTokenByRefreshToken(@QueryParam("grant_type") @Pattern(regexp = "(refresh_token)", message = "grant_type must be set to “refresh_token”.") String grantType, @QueryParam("refresh_token") @NotBlank(message = "refresh_token cannot be blank!") String refreshToken, @QueryParam("client_id") String clientId, @QueryParam("code_verifier") @NotBlank(message = "code_verifier cannot be blank!") String codeVerifier) {
        AccessTokenDomain accessTokenDomain = authorizationService.getAccessTokenByRefreshToken(grantType, refreshToken, clientId, codeVerifier);

        AccessTokenResponseDTO response = buildAccessTokenResponseDTO(accessTokenDomain);

        return Response.ok().entity(response).header(HttpHeaders.CACHE_CONTROL, CacheControlDirectives.NO_STORE).build();
    }

    @GET
    @Path("/callback")
    @Produces(MediaType.APPLICATION_JSON)
    public Response returnCallback(@QueryParam("code") String code, @QueryParam("state") String state){
        return Response.ok().entity("{\"code\":\""+code+"\",\"state\":\""+state+"\"}").build();
    }

    private AccessTokenResponseDTO buildAccessTokenResponseDTO(AccessTokenDomain accessTokenDomain) {
        AccessTokenResponseDTO response = new AccessTokenResponseDTO();
        response.setAccessToken(accessTokenDomain.getAccessToken());
        response.setExpiresIn(accessTokenDomain.getExpiresIn());
        response.setTokenType(accessTokenDomain.getTokenType());
        response.setRefreshToken(accessTokenDomain.getRefreshToken());
        return response;
    }
}
